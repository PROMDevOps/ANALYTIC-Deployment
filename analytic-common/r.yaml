---
# Source: helm-dap/charts/vector-kafka-to-influxdb/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vector-kafka-to-influxdb
  labels:
    helm.sh/chart: vector-kafka-to-influxdb-0.22.1
    app.kubernetes.io/name: vector-kafka-to-influxdb
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: Aggregator
    app.kubernetes.io/version: "0.30.0-distroless-libc"
    app.kubernetes.io/managed-by: Helm
    
automountServiceAccountToken: true
---
# Source: helm-dap/charts/vector-kafka-to-influxdb/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: vector-kafka-to-influxdb
  labels:
    helm.sh/chart: vector-kafka-to-influxdb-0.22.1
    app.kubernetes.io/name: vector-kafka-to-influxdb
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: Aggregator
    app.kubernetes.io/version: "0.30.0-distroless-libc"
    app.kubernetes.io/managed-by: Helm
    
data:
  vector.yaml: |
    data_dir: /vector-data-dir
    sinks:
      stdout:
        encoding:
          codec: json
        inputs:
        - kafka_to_influxdb
        type: console
    sources:
      internal_metrics:
        type: internal_metrics
      kafka_to_influxdb:
        bootstrap_servers: kafka:9092
        group_id: to-influxdb
        topics:
        - prom-dap
        type: kafka
    transforms: {}
---
# Source: helm-dap/templates/vector-filter-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: vector-filter-cm
  annotations:
    checksum/config1: 7ac6d8680ad525238e50113cb7c8748624f69ad871912d75f7a1e7f65a05e825
    checksum/config4: 0eef00f218aefd9ea47a9461278a1dc0adfe1a5b4d18f41c784da0eb44580424
data:
  process_cloud_logs.vrl: |-
    json_str = .message
    . = {}
    .message = parse_json!(string!(json_str))
    
    .type = "audit-log"
    .category = .message.resource.type
    .project_id = .message.resource.labels.project_id
    .timestamp = .message.timestamp
    .pod_name_vector = get_env_var!("POD_NAME")
    
    if (.category == "http_load_balancer") {
        if (.message.httpRequest.referer != null) {    
            refererUrl = parse_url!(to_string!(.message.httpRequest.referer))
            .refererHost = refererUrl.host
            .refererPath = refererUrl.path
        }
    
        if (.message.httpRequest.requestUrl != null) {    
            requestUrl = parse_url!(to_string!(.message.httpRequest.requestUrl))
            .requestHost = requestUrl.host
            .requestPath = requestUrl.path
        }
    
        .latency = .message.httpRequest.latency
        .remoteIp = .message.httpRequest.remoteIp
        .requestMethod = .message.httpRequest.requestMethod
        .requestSize = .message.httpRequest.requestSize
        .responseSize = .message.httpRequest.responseSize
        .status = .message.httpRequest.status
    } else if (.category == "k8s_cluster") {
        .cluster_name = .message.resource.labels.cluster_name
        .location = .message.resource.labels.location
    } else if (.category == "nat_gateway") {
        .dest_ip = .message.jsonPayload.connection.dest_ip
    }
    
  process_app_logs_syslog.vrl: |-
    org_obj = .
    . = {}
    .message = null
    
    if (org_obj.log != null) {
        .message = org_obj.log
    }
    
    if (org_obj.output != null) {
        .message = org_obj.output
    }
    
    if (org_obj.message != null) {
        .message = org_obj.message
    }
    
    if (.message == null) || (.message == "") {
        .message = org_obj
    }
    
    .namespace = org_obj.kubernetes.namespace_name
    .pod = org_obj.kubernetes.pod_name
    .container = org_obj.kubernetes.container_name
    .app_kubernetes_io_component = org_obj.kubernetes.labels."app.kubernetes.io/component"
    .app_kubernetes_io_name = org_obj.kubernetes.labels."app.kubernetes.io/name"
    .app_kubernetes_io_instance = org_obj.kubernetes.labels."app.kubernetes.io/instance"
    
    .type = "app-log"
    
    #gke:evermed-devops-prod:gke-devops-cicd
    
    tokens = split!(org_obj.appname, ":")
    .cluster = tokens[2]
    .project = tokens[1]
    .platform = tokens[0]
    .timestamp = now()
---
# Source: helm-dap/charts/vector-kafka-to-influxdb/templates/service-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: vector-kafka-to-influxdb-headless
  labels:
    helm.sh/chart: vector-kafka-to-influxdb-0.22.1
    app.kubernetes.io/name: vector-kafka-to-influxdb
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: Aggregator
    app.kubernetes.io/version: "0.30.0-distroless-libc"
    app.kubernetes.io/managed-by: Helm
    
  annotations:
spec:
  clusterIP: None
  ports:    
  selector:
    app.kubernetes.io/name: vector-kafka-to-influxdb
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: Aggregator
  type: ClusterIP
---
# Source: helm-dap/charts/vector-kafka-to-influxdb/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vector-kafka-to-influxdb
  labels:
    helm.sh/chart: vector-kafka-to-influxdb-0.22.1
    app.kubernetes.io/name: vector-kafka-to-influxdb
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: Aggregator
    app.kubernetes.io/version: "0.30.0-distroless-libc"
    app.kubernetes.io/managed-by: Helm
    
  annotations:
    {}
spec:
  replicas: 1
  podManagementPolicy: OrderedReady
  selector:
    matchLabels:
      app.kubernetes.io/name: vector-kafka-to-influxdb
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: Aggregator
  serviceName: vector-kafka-to-influxdb-headless
  template:
    metadata:
      annotations:
        checksum/config: 1d7addf383aecb84ef79de835a7f6d7d7cb0082a1189d4dd61a7ada802143aa6
      labels:
        app.kubernetes.io/name: vector-kafka-to-influxdb
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/component: Aggregator
        vector.dev/exclude: "true"
    spec:
      serviceAccountName: vector-kafka-to-influxdb
      dnsPolicy: ClusterFirst
      containers:
        - name: vector
          image: "timberio/vector:0.30.0-distroless-libc"
          imagePullPolicy: IfNotPresent
          args:
            - --config-dir
            - /etc/vector/
          env:
          ports:      
          volumeMounts:
            - name: data
              mountPath: "/vector-data-dir"
            - name: config
              mountPath: "/etc/vector/"
              readOnly: true
            - mountPath: /scripts/
              name: scripts
              readOnly: true
      terminationGracePeriodSeconds: 60
      volumes:
        - name: config
          projected:
            sources:
              - configMap:
                  name: vector-kafka-to-influxdb
        - configMap:
            name: vector-filter-cm
          name: scripts
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: [ReadWriteOnce]
      resources:
        requests:
          storage: 10Gi
---
# Source: helm-dap/templates/grafana-ing.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana-ing
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: HTTP  
    kubernetes.io/ingress.class: "nginx"
spec:
  tls:
    - hosts:
      - 
      secretName: grafana-cert
  rules:
    - host: 
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: grafana
                port:
                  number: 80
---
# Source: helm-dap/templates/influx-ing.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: influx-ing
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: HTTP  
    kubernetes.io/ingress.class: "nginx"
spec:
  tls:
    - hosts:
      - 
      secretName: influx-cert
  rules:
    - host: 
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: influxdb
                port:
                  number: 8086
---
# Source: helm-dap/templates/kafka-ing.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kafka-ing
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: HTTP  
    kubernetes.io/ingress.class: "nginx"
spec:
  tls:
    - hosts:
      - 
      secretName: kafka-cert
  rules:
    - host: 
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: kafka-ui
                port:
                  number: 80
---
# Source: helm-dap/templates/grafana-cert.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: grafana-cert
spec:
  secretName: grafana-cert
  dnsNames:
    - 
  issuerRef:
    name: lets-encrypt-issuer-prod
    kind: ClusterIssuer
    group: cert-manager.io
---
# Source: helm-dap/templates/influx-cert.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: influx-cert
spec:
  secretName: influx-cert
  dnsNames:
    - 
  issuerRef:
    name: lets-encrypt-issuer-prod
    kind: ClusterIssuer
    group: cert-manager.io
---
# Source: helm-dap/templates/kafka-cert.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: kafka-cert
spec:
  secretName: kafka-cert
  dnsNames:
    - 
  issuerRef:
    name: lets-encrypt-issuer-prod
    kind: ClusterIssuer
    group: cert-manager.io
---
# Source: helm-dap/templates/grafana-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: grafana-credentials
spec:
  refreshInterval: 1m
  secretStoreRef:
    kind: ClusterSecretStore
    name: k8s-secret-store      # name of the SecretStore (or kind specified)
  target:
    name: grafana-credentials       # name of the k8s Secret to be created
  data:
  - secretKey: GRAFANA_USER
    remoteRef:
      key: initial-secret
      property: GRAFANA_USER

  - secretKey: GRAFANA_PASSWORD
    remoteRef:
      key: initial-secret
      property: GRAFANA_PASSWORD
---
# Source: helm-dap/templates/influx-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: influx-credentials
spec:
  refreshInterval: 1m
  secretStoreRef:
    kind: ClusterSecretStore
    name: k8s-secret-store      # name of the SecretStore (or kind specified)
  target:
    name: influx-credentials       # name of the k8s Secret to be created
  data:
  - secretKey: DOCKER_INFLUXDB_INIT_USERNAME
    remoteRef:
      key: initial-secret
      property: INFLUXDB_USER

  - secretKey: DOCKER_INFLUXDB_INIT_PASSWORD
    remoteRef:
      key: initial-secret
      property: INFLUXDB_PASSWORD

  - secretKey: DOCKER_INFLUXDB_INIT_ADMIN_TOKEN
    remoteRef:
      key: initial-secret
      property: INFLUXDB_TOKEN
---
# Source: helm-dap/templates/kafka-ui-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: kafka-ui-credential
spec:
  refreshInterval: 1m
  secretStoreRef:
    kind: ClusterSecretStore
    name: k8s-secret-store      # name of the SecretStore (or kind specified)
  target:
    name: kafka-ui-credential       # name of the k8s Secret to be created
  data:
  - secretKey: SPRING_SECURITY_USER_NAME
    remoteRef:
      key: initial-secret
      property: KAFKA_UI_USER

  - secretKey: SPRING_SECURITY_USER_PASSWORD
    remoteRef:
      key: initial-secret
      property: KAFKA_UI_PASSWORD
